####################################
#
# cointegration analysis
#
####################################


align_integ_oder <- function(ts.1 = NULL, ts.2 = NULL, iswi = 1) {
  # .
  int.order.ts.1 <- determine_integration_order(
    original.ts = ts.1,
    detection.mode = "ADF",
    alternative.hypoth = "stationary",
    max.order = 3,
    Integ.order.significance = 0.05
  )
  int.order.ts.2 <- determine_integration_order(
    original.ts = ts.2,
    detection.mode = "ADF",
    alternative.hypoth = "stationary",
    max.order = 3,
    Integ.order.significance = 0.05
  )

  # .
  if (iswi < int.order.ts.1) {
    ts.1 <- c(rep(NA, (int.order.ts.1 - iswi)), diff(ts.1, (int.order.ts.1 - iswi)))
  }
  # .
  if (iswi < int.order.ts.2) {
    ts.2 <- c(rep(NA, (int.order.ts.2 - iswi)), diff(ts.2, (int.order.ts.2 - iswi)))
  }
  ts <- zoo::na.trim(cbind(ts.1, ts.2), sides = "both")
  # .
  output <- list()
  # .
  output[["ts.1"]] <- ts[, 1]
  output[["ts.2"]] <- ts[, 2]
  # . fke-d acu id yefghe-n
  return(output)
  # . Tanmirt
}
#########################################
cointeg.report <- function(time.serie.y = NULL, time.serie.x = NULL, test.mode = "johansen") {
  # . Phillips-Perron Unit Root Test
  # if(test.mode == "Phillips-Perron"){
  # pp.result <- ur.pp(ts(time.serie.y,time.serie.x))
  # }
  # .
  ts_amaynut <- align_integ_oder(ts.1 = time.serie.y, ts.2 = time.serie.x, iswi = 1)
  # .
  time.serie.y <- ts_amaynut$ts.1
  time.serie.x <- ts_amaynut$ts.2
  # .
  # . Johansen Test
  if (test.mode == "Johansen") {
    ca.result <- ca.jo(data.frame(time.serie.y, time.serie.x),
      type = "eigen", K = 2,
      spec = "longrun", season = 4
    )
    # .
    cont.f_statistic2 <- ca.result@teststat
    # .
  }
  # .
  if (test.mode == "Philips-Ouaris") {
    # .
    po.result <- po.test(data.frame(time.serie.y, time.serie.x), demean = TRUE, lshort = TRUE)
    # .
    cont.p_value <- po.result$p.value
    # .
  }
  # .
}
#########################################
ekkes_tasawen_f <- function(ts_x = NULL) {
  y <- 1:length(ts_x)
  return(lm(ts_x ~ y)$residuals)
}

#########################################
coherence_n_snat_f <- function(TS_1 = NULL, TS_2 = NULL, ekkes_tassawent = FALSE, ekkes_ddurt = FALSE, fesred = FALSE) {
  # .......................
  if (ekkes_tassawent == TRUE) {
    print("a nekkes i teqcicin nnegh takessart negh tassawent ....")
    TS_1 <- ekkes_tasawen_f(TS_1)
    TS_2 <- ekkes_tasawen_f(TS_2)
  }
  # .......................
  if (ekkes_ddurt == TRUE) {
    print("a nekkes i ddurt(seasonality) ....")
    stop("rnu-d kra ar dagi ")
  }
  # .......................
  ts_snat <- data.frame(TS_1 = TS_1, TS_2 = TS_2)
  if (fesred == TRUE) {
    x <- 1:length(TS_1)
    g <- ggplot(ts_snat, aes(x)) +
      geom_line(aes(y = scale(TS_1), colour = "TS 1")) +
      geom_line(aes(y = scale(TS_2), colour = "TS 2"))
    g <- g + labs(colour = NULL)
    g
  }
  return(round(mean(stats::spec.pgram(ts_snat, plot = fesred, span = 8)$coh), 2))
  # .......................
}
# ................................................

#' Bivariate Granger Causality (matrix)
#' @param tisefka : raw data
#' @return matrix containing bivariate granger-causlities

tuqna_ts_akk <- function(tisefka = NULL) {
#--------------------
  datum <- row.names(tisefka)
  tisefka <- purrr::map_df(.x= tisefka,.f = interp_na_value)
  tisefka <- data.frame(tisefka,check.names = FALSE)
#------------------
  output_n_tagara <- list()
  #------------------ 
  tuqniwin <- list()
  for (z in colnames(tisefka)) {
    tuqniwin[[z]] <- apply(tisefka, 2, function(h) coherence_n_snat_f(TS_1 = h, TS_2 = tisefka[, z]))
  }
  tuqniwin <- as.matrix(data.frame(tuqniwin, check.names = FALSE))
  diag(tuqniwin) <- NA
  tuqniwin <- apply(tuqniwin, 2, function(x) x[!is.na(x)])
  #------------------
  output_n_tagara[["tuqniwin"]] <- tuqniwin
  #------------------
  return(output_n_tagara)
}
#-------------------------------------------------
ekkes_ddurt_f <- function(ts_x = NULL) {
  # .........................
  p <- stats::spec.pgram(ts_x, plot = TRUE)
  dd <- data.frame(freq = p$freq, spec = p$spec)
  order <- dd[order(-dd$spec), ]
  top2 <- head(order, 2)
  # display the 2 highest "power" frequencies
  top2
  # convert frequency to time periods
  time <- 1 / top2$f
  time
  # .........................
}
